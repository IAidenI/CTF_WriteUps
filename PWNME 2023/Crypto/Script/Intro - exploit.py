import random
from itertools import cycle

# Recupère le message chiffré et le message partiel en clair
cipher_tmp = open("./message-encrypted.txt", "r").read()
partial_plain = open("./intercepted-original-mesage.txt").read()

# Enleve des ',' qui se trouvent dans le fichier et le convertit en une liste
cipher_tmp = cipher_tmp.replace(',', '')
cipher = []
for i in range(0, len(cipher_tmp), 4):
    cipher.append(''.join(cipher_tmp[i:i+4]))

def Partial_Secret():
    i = 0
    SECRET = []
    # Pour chaque caractères, on viens regarder si dans le message intercepté
    # contient le caractère '*' et si se n'est pas le cas, on vient effectuer un XOR
    # entre le message intercepté et le message chiffré
    for a,b in zip(cipher, partial_plain):
        if i == 16:
            # Le secret ne contient que 16 caractères, donc si les 16 sont atteint on sort
            break
        elif b == '*':
            SECRET.append('*')
        else:
            SECRET.append(str(int(a)^ord(b)))
        i += 1
    return SECRET

def decrypt(message):
    Partial_message = ""
    for a,b,c  in zip(message, cycle(SECRET), partial_plain):
        if b == '*':
            Partial_message += c
        else:
            Partial_message += chr(int(a) ^ int(b))

    print(f"Partial message : {Partial_message}")

def decrypt_partial():
    i = 0
    # Recupere le cipher sans les 64 premier caractères
    CIPHER = cipher[(len(cipher) - 16) - 16:len(cipher) - 16]
    partial = "ood luck for the"
    for a,b in zip(partial, CIPHER):
        if a == '*':
            # On place un '*' si c'est inconnu pour le secret
            Partial_SECRET[i] = a
            # Pour revenir au premier indice du secret si on a atteint la fin du secret
            i = (i + 1) % len(Partial_SECRET)
            continue
        else:
            # Si le secret que l'on a trouvé contient déjà une valeur, alors on ne va pas la réécrire.
            if Partial_SECRET[i] == '*':
                Partial_SECRET[i] = (str(ord(a)^int(b)))
            # Pour revenir au premier indice du secret si on a atteint la fin du secret
            i = (i + 1) % len(Partial_SECRET)
    return Partial_SECRET


Partial_SECRET = Partial_Secret()
SECRET = decrypt_partial()
decrypt(cipher)