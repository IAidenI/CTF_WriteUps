from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
import time
import os
import sys

def decrypt_KEY(IV, cipher):
    key = ""
    for a,b in zip(IV, cipher):
        key += str(hex(int(a, 16)^int(b, 16))[2:])
    # On inverse le sens de KEY car dans l'algo, c'était pour KEY[::-1]
    # ce qui veux dire que pour faire le XOR, il a pris la KEY inversé
    key = ''.join(reversed([key[i:i+2] for i in range(0, len(key), 2)]))
    return key

def decrypt(key, IV, cipher):
    # Tentative de déchiffrement du message
    ciphertext = AES.new(key, AES.MODE_CBC, IV)
    plaintext = unpad(ciphertext.decrypt(cipher), AES.block_size)
    # Il est possible de trouver des paires de key/iv qui ne soient pas les bonnes
    # mais qui soient tout de même dechiffré car l'AES est une fonction de chiffrement
    # déterministe (un même message chiffré avec la même clé et le même iv produira toujours
    # le même message. On sais que dans le flag il y aura "PWNME", donc on vérifie qu'il soit dedans
    if "PWNME" in plaintext.decode():
        print(f"[+] Plain text trouvé : {plaintext.decode()}")
        print(f"[+] Final KEY : {key.hex()}")
        print(f"[+] Final IV : {IV.hex()}")
        sys.exit(1)

def plaintext(cipher):
    print("\n[*] Recherche du plaintext en cours...")

    # Crée un payload, il car on veux deux caractères hexa, on commence à 0x0001 jusqu'à 0xffff
    for payload_iv in range(1, int('0xffff', 16)):
        try:
            # On vient récuperer l'IV à partir du cipher auquel on ajoute les caractères innconus
            IV = "{:04x}".format(payload_iv) + cipher[:28]
            # On cherche la key corespondante
            key = decrypt_KEY(IV, cipher[len(cipher) - 32:len(cipher)])

            # On les convertit sous le bon format avant de les envoyer
            decrypt(bytes.fromhex(key), bytes.fromhex(IV), bytes.fromhex(cipher[28:len(cipher) - 32]))

            payload_iv += 1
        except SystemExit:
            return
        except:
            payload_iv += 1
    print("[-] Plaintext introuvable.")

cipher = 'ca92b5919084c02658a2e3d57ee3a37b8ab32e581d2615359cc7858e966090d328df' \
         '2be8b5ad889561d9abce6f961fe03a95a2051e882db2373b33b5a43a1c13ff62af7f' \
         '835df3cc1ccc64571e74f8b84587c727d56c4d37983e7b80ce3c'
plaintext(cipher)